#!/usr/bin/env python

import sys
import re
import ldap
import readline

config_file = "yubikey-ldap.conf"

class conf(object):
    uri = ""
    bind_dn = ""
    bind_pw = ""
    base_dn = ""
    uid_attr = "uid"
    yubi_id_len = 12

def debug(message):
    print("DEBUG: %s" % message)

def info(message):
    print("INFO: %s" % message)

def warning(message):
    print("WARNING: %s" % message)

def error(message):
    print("ERROR: %s" % message)

def fatal(message, exitcode = 1):
    print("FATAL: %s" % message)
    sys.exit(exitcode)

def uid2dn(uid):
    return "%s=%s,%s" % (conf.uid_attr, uid, conf.base_dn)

class LdapUidCompleter:
    def __init__(self, ldap_con, conf):
        self.words = []
        self.prefix = None
        self.ldap_con = ldap_con
        self.conf = conf

        readline.set_completer(self.complete)
        readline.parse_and_bind("tab: complete")

    def get_uids_for_prefix(self, prefix):
        filterstr = "(uid=%s*)" % prefix
        attrlist = [ 'uid' ]
        res = self.ldap_con.search_s(self.conf.base_dn, ldap.SCOPE_SUBTREE, filterstr, attrlist)
        matches = [r[1]['uid'][0] for r in res]
        return matches

    def complete(self, prefix, index):
        if prefix != self.prefix:
            self.matching_words = self.get_uids_for_prefix(prefix)
            self.prefix = prefix

        try:
            return self.matching_words[index]
        except IndexError:
            return None

class YubiKeyManager(object):
    def __init__(self, conf):
        self.conf = conf

        # Connect to the LDAP server
        try:
            self.con = ldap.initialize(conf.uri)
            self.con.bind_s(conf.bind_dn, conf.bind_pw, ldap.AUTH_SIMPLE)
        except ldap.INVALID_CREDENTIALS:
            fatal("Invalid credentials. Check bind_dn [%s] and bind_pw [%s] values." % (conf.bind_dn, conf.bind_pw))
        except ldap.SERVER_DOWN:
            fatal("Connection error. Check conf.uri value.")
        except ldap.LDAPError, e:
            fatal("%s" % e.args[0]["desc"])

        self.menu = {
            'a' : { 'label' : 'add', 'callback' : self.cmd_add_yubikey },
            'd' : { 'label' : 'delete', 'callback' : self.cmd_del_yubikey },
            'u' : { 'label' : 'other user' },
            'q' : { 'label' : 'quit' },
        }

        completer = LdapUidCompleter(self.con, self.conf)

    def cmd_add_yubikey(self):
        # Read YubiKey id, chop conf.yubi_id_len chars
        while True:
            print "\nEnter YubiKey ID (%d chars minimum, best way is to touch the key)" % self.conf.yubi_id_len
            ykid = raw_input("YubiKey ID: ")
            if not ykid:
                return
            if re.search('[^a-z]', ykid):
                print "Invalid YubiKey ID. Please try again."
                continue
            if len(ykid) < conf.yubi_id_len:
                print "YubiKey ID must be at least %d characters. Please try again." % conf.yubi_id_len
                continue
            ykid = ykid[:conf.yubi_id_len]

            # Check YubiKey id is already there if exists
            if ykid in self.user_record['yubiKeyIds']:
                print "YubiKey '%s' is already assigned to '%s'. Please try again." % (ykid, self.user_record['uid'])
                continue

            print "\nAssigning YubiKey '%s' to '%s'" % (ykid, self.user_record['uid'])
            yesno = raw_input("Commit? [Y/n] ")
            if yesno == '' or yesno[0] in ('y', 'Y'):
                break

        # Check yubiKeyUser objectClass and Add if doesn't exist
        if 'yubiKeyUser' not in self.user_record['objectClasses']:
            debug("Adding objectClass:yubiKeyUser to dn:%(dn)s" % self.user_record)
            mod_attrs = [( ldap.MOD_ADD, 'objectClass', 'yubiKeyUser' )]
            self.con.modify_s(self.user_record['dn'], mod_attrs)
            self.refresh_user_record()

        # Save yubiKey data to LDAP
        debug("Adding yubiKeyId:%s to dn:%s" % (ykid, self.user_record['dn']))
        mod_attrs = [( ldap.MOD_ADD, 'yubiKeyId', ykid)]
        self.con.modify_s(self.user_record['dn'], mod_attrs)
        self.refresh_user_record()

    def cmd_del_yubikey(self):
        def _del_ykid(ykid):
            debug("Removing yubiKeyId:%s from dn:%s" % (ykid, self.user_record['dn']))
            mod_attrs = [( ldap.MOD_DELETE, 'yubiKeyId', ykid)]
            self.con.modify_s(self.user_record['dn'], mod_attrs)
            self.refresh_user_record()

        self.display_user_info()
        while True:
            print "Enter YubiKey or the index number. Enter when done. "
            ykid = raw_input("YubiKey to Delete: ")
            if not ykid:
                break
            if ykid[:conf.yubi_id_len] in self.user_record['yubiKeyIds']:
                _del_ykid(ykid)
            else:
                try:
                    index = int(ykid) - 1
                    ykid = self.user_record['yubiKeyIds'][index]
                    _del_ykid(ykid)
                except:
                    continue

    def select_user(self, search_list):
        for index in range(len(search_list)):
            print "% 3d)  %s (%s)" % (index + 1, search_list[index][1]['uid'][0], search_list[index][1]['cn'][0])
        while True:
            try:
                index = int(raw_input("Select user: "))
                if index < 1:
                    raise ValueError
                return search_list[index-1]
            except (ValueError, IndexError):
                error("Invalid selection")

    def user_menu(self, cmds):
        prompt = " / ".join(["(%s) %s" % (cmd, self.menu[cmd]['label']) for cmd in cmds])
        prompt += ": "
        while True:
            cmd = raw_input(prompt)
            if cmd in cmds:
                return cmd

    def refresh_user_record(self, uid = None):
        if not uid:
            uid = self.user_record['uid']
        uid_inval_chrs = re.search('([^\w\.\-])', uid)
        if uid_inval_chrs:
            error("Invalid characters in username: %s" % uid_inval_chrs.group(1))
            return False
        filterstr = "(uid=%s)" % uid
        attrlist = [ 'objectClass', 'uid', 'cn', 'yubiKeyId' ]
        res = self.con.search_s(self.conf.base_dn, ldap.SCOPE_SUBTREE, filterstr, attrlist)
        if not res:
            error("Unknown user: %s" % uid)
            return False
        res = res[0]

        self.user_record = {
            'dn' : res[0],
            'objectClasses' : res[1]['objectClass'],
            'uid' : res[1]['uid'][0],
            'cn' : 'cn' in res[1] and res[1]['cn'][0] or '',
            'yubiKeyIds' : 'yubiKeyId' in res[1] and res[1]['yubiKeyId'] or {},
        }

        return True

    def display_user_info(self):
        print "%(cn)s [%(uid)s] has" % self.user_record,
        if not self.user_record['yubiKeyIds']:
            print "no assigned YubiKeys"
        elif len(self.user_record['yubiKeyIds']) == 1:
            print "1 assigned YubiKey"
        else:
            print "%d assigned YubiKeys" % len(self.user_record['yubiKeyIds'])
        for index in range(len(self.user_record['yubiKeyIds'])):
            print "% 3d)  %s" % (index + 1, self.user_record['yubiKeyIds'][index])
        print

    def main(self):
        print "Enter username to manage (<tab> to autocomplete)"
        user = raw_input("Username: ")
        if not self.refresh_user_record(uid = user):
            return

        while True:
            self.display_user_info()

            command = self.user_menu(cmds = len(self.user_record['yubiKeyIds'])>0 and "aduq" or "auq")
            if command not in self.menu:
                warning("Invalid command. Please try again.")
                continue

            if 'callback' in self.menu[command]:
                self.menu[command]['callback']()
            elif command == "u":
                return  # self.user_recordtart main() in the caller
            elif command == "q":
                sys.exit(0)
            else:
                error("Not yet implemented...")

if __name__ == "__main__":
    # Temporary config-like handling.
    # We'll do better later.
    try:
        execfile(config_file)
    except:
        fatal("Failure reading config file: %s" % config_file)
    
    ykmgr = YubiKeyManager(conf)

    # Enter main loop
    while True:
        try:
            ykmgr.main()
        except (KeyboardInterrupt, EOFError):
            print "\n"
            break

    #con.unbind_s()
    #print con.whoami_s()
